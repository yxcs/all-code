(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{444:function(t,i,a){"use strict";a.r(i);var n=a(8),e=Object(n.a)({},(function(){var t=this,i=t.$createElement,a=t._self._c||i;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"到底什么是bfc、ifc、gfc和ffc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#到底什么是bfc、ifc、gfc和ffc"}},[t._v("#")]),t._v(" 到底什么是BFC、IFC、GFC和FFC")]),t._v(" "),a("p",[t._v("软件开发的一般被称为民工，搞前端的，有人形容为是掏粪工，说白了连民工级别高都没有。说直接点就是个制作界面的，注意，连设计界面的都算不上，一般前端都是拿着设计稿去照这样子开发的。\n说这些无非是觉得前端前端，却一点也不高端啊，就连逼格高的术语都找不到几个，但少不代表没有，比如Closure、BFC、IFC、GFC和FFC，等等，怎么这么多C啊，C==操？本文就简单列举下这几个C到底都他妈的什么意思，虽然这些东西都没什么卵用，但万一被哪个傻缺面试官来跟你贫这些词汇呢？有备无患。CSS2.1中只有BFC和IFC, CSS3中才有GFC和FFC。")]),t._v(" "),a("h2",{attrs:{id:"what-s-fc？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#what-s-fc？"}},[t._v("#")]),t._v(" What's FC？")]),t._v(" "),a("p",[t._v("一定不是KFC，FC的全称是：Formatting Contexts，是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。")]),t._v(" "),a("h2",{attrs:{id:"bfc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bfc"}},[t._v("#")]),t._v(" BFC")]),t._v(" "),a("p",[t._v('BFC(Block Formatting Contexts)直译为"块级格式化上下文"。Block Formatting Contexts就是页面上的一个隔离的渲染区域，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此。如何产生BFC？\nfloat的值不为none。 \noverflow的值不为visible。 \nposition的值不为relative和static。\ndisplay的值为table-cell, table-caption, inline-block中的任何一个。 \n那BFC一般有什么用呢？比如常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行。')]),t._v(" "),a("h2",{attrs:{id:"ifc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ifc"}},[t._v("#")]),t._v(" IFC")]),t._v(" "),a("p",[t._v('IFC(Inline Formatting Contexts)直译为"内联格式化上下文"，IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响)\nIFC中的line box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。 同个ifc下的多个line box高度会不同。 IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。\n那么IFC一般有什么用呢？\n水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。\n垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。')]),t._v(" "),a("h2",{attrs:{id:"gfc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gfc"}},[t._v("#")]),t._v(" GFC")]),t._v(" "),a("p",[t._v('GFC(GridLayout Formatting Contexts)直译为"网格布局格式化上下文"，当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。 \n那么GFC有什么用呢，和table又有什么区别呢？首先同样是一个二维的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。')]),t._v(" "),a("h2",{attrs:{id:"ffc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ffc"}},[t._v("#")]),t._v(" FFC")]),t._v(" "),a("p",[t._v('FFC(Flex Formatting Contexts)直译为"自适应格式化上下文"，display值为flex或者inline-flex的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少safari和chrome还是OK的，毕竟这俩在移动端才是王道。\nFlex Box 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。\n伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。')])])}),[],!1,null,null,null);i.default=e.exports}}]);