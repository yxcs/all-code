<!DOCTYPE html>
<html>
  <head>
    <title>æ¶ˆæ¯ä¼ é€’ - Google Chrome æ‰©å±•ç¨‹åºå¼€å‘æ–‡æ¡£ï¼ˆéå®˜æ–¹ä¸­æ–‡ç‰ˆï¼‰</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link href="../static/css/site.css" rel="stylesheet" type="text/css">
    <link href="../../developer.chrome.com/static/css/print.css" rel="stylesheet" type="text/css" media="print">
    <link href="../../developer.chrome.com/static/css/prettify.css" rel="stylesheet" type="text/css">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  </head>

  <body>


<!-- Copyright © 2005. Spidersoft Ltd -->
<style>
A.applink:hover {border: 2px dotted #DCE6F4;padding:2px;background-color:#ffff00;color:green;text-decoration:none}
A.applink       {border: 2px dotted #DCE6F4;padding:2px;color:#2F5BFF;background:transparent;text-decoration:none}
A.info          {color:#2F5BFF;background:transparent;text-decoration:none}
A.info:hover    {color:green;background:transparent;text-decoration:underline}
</style>
<div style='BORDER: 1px solid #DCE6F4; MARGIN-TOP: 20px; MARGIN-BOTTOM: 20px; MARGIN-LEFT: 5px; MARGIN-RIGHT: 5px; PADDING: 5px; BACKGROUND-COLOR: #eef8ff;line-height:180%; COLOR: #000000; font-family: Arial; font-size: 8pt; width=100%; FILTER: progid:DXImageTransform.Microsoft.Gradient(GradientType=0, StartColorStr="#FFFFFFFF", EndColorStr="#F2F5FAFF");'>
This page was saved using <a class="applink" href="http://www.spidersoft.com"><b>WebZIP 7.0.3.1030</b></a> <a class="applink" href="http://www.spidersoft.com"><b>offline browser</b></a>  on  12/24/13 11:31:36.<br>
<b>Address:</b> <a class="info" href="https://crxdoc-zh.appspot.com/extensions/messaging.html">https://crxdoc-zh.appspot.com/extensions/messaging.html</a><br>
<b>Title:</b> æ¶ˆæ¯ä¼ é€’ - Google Chrome æ‰©å±•ç¨‹åºå¼€å‘æ–‡æ¡£ï¼ˆéå®˜æ–¹ä¸­æ–‡ç‰ˆï¼‰ &nbsp;&bull;&nbsp; <b>Size:</b> 43672<br></div>
<!-- /Copyright © 2005. Spidersoft Ltd -->


    <div id="gc-topnav">
      <table><tr>
      <td id="chrome-logo">
        <a href="extensions.html" title="Google Chrome æ‰©å±•ç¨‹åº" id="view-original">
          <img src="../../developer.chrome.com/static/images/chrome-logo.png" alt=""> chrome
        </a>
        <script type="text/javascript">
          document.getElementById('view-original').href = "https://developer.chrome.com" + location.pathname;
        </script>
        <div id="platform-chooser">
          <button id="platform-chooser-toggle" data-menu="platform-chooser-popup">
            æ‰©å±•ç¨‹åº &#x25be;&#x202F;
          </button>
          <div id="platform-chooser-popup">
            <button class="apps" data-href="/apps/about_apps.html"><!--@apps-->åº”ç”¨</button>
            <button class="extensions" data-href="/extensions"><!--@extensions-->æ‰©å±•ç¨‹åº</button>
          </div>
        </div>ï¼ˆéå®˜æ–¹ä¸­æ–‡ç‰ˆï¼‰
      </td>
      <td>
        <ul>
          <li>
            <a href="samples.html"
               title="ç¤ºä¾‹ æ‰©å±•ç¨‹åºï¼ˆåŒ…å«æºä»£ç ï¼‰"><!--@Samples-->ç¤ºä¾‹</a>
          </li>
          <li>
            <a href="http://groups.google.com/a/chromium.org/group/chromium-extensions"
               title="Google Chrome æ‰©å±•ç¨‹åºå¼€å‘è€…è®ºå›"
               target="_blank"><!--@Group-->è®ºå›ï¼ˆè‹±æ–‡ï¼‰</a>
          </li>
          <li>
            <a href="http://stackoverflow.com/tags/google-chrome-extension/info"
               title="Stack Overflow ä¸Šçš„ [google-chrome-extension] æ ‡ç­¾"
               target="_blank">Stack overflow</a>
          </li>
        </ul>
      </td>
      </tr></table>
    </div>
    <div id="gc-topnav-space"></div>
    <div id="gc-container">
      <div id="gc-sidebar">
        <g:plusone></g:plusone>
        <ul 
            class="level1 ">
        <li class="level2">
              <a href="getstarted.html" class="level2 ">å…¥é—¨</a>
        </li><li class="level2">
              <a href="overview.html" class="level2 ">æ¦‚è¿°</a>
        </li><li class="level2">
              <a href="whats_new.html" class="level2 ">æ–°å¢åŠŸèƒ½</a>
        </li><li class="level2">
              <a href="devguide.html" class="level2 ">å¼€å‘è€…æŒ‡å—</a>
          <ul 
              class="level2 ">
          <li class="level3">
              <a class="button level3">
                <span class="level3">æµè§ˆå™¨ç”¨æˆ·ç•Œé¢</span>
                <div class="toggleIndicator level3"></div>
              </a>
            <ul toggleable
                class="level3 hidden">
            <li class="level4">
                  <a href="browserAction.html" class="level4 ">æµè§ˆå™¨æŒ‰é’®</a>
            </li><li class="level4">
                  <a href="contextMenus.html" class="level4 ">å³é”®èœå•</a>
            </li><li class="level4">
                  <a href="desktop_notifications.html" class="level4 ">æ¡Œé¢é€šçŸ¥</a>
            </li><li class="level4">
                  <a href="omnibox.html" class="level4 ">å¤šåŠŸèƒ½æ¡†</a>
            </li><li class="level4">
                  <a href="options.html" class="level4 ">é€‰é¡¹é¡µé¢</a>
            </li><li class="level4">
                  <a href="override.html" class="level4 ">æ›¿ä»£é¡µé¢</a>
            </li><li class="level4">
                  <a href="pageAction.html" class="level4 ">é¡µé¢æŒ‰é’®</a>
            </li>
            </ul>
          </li><li class="level3">
              <a class="button level3">
                <span class="level3">æµè§ˆå™¨äº¤äº’</span>
                <div class="toggleIndicator level3"></div>
              </a>
            <ul toggleable
                class="level3 hidden">
            <li class="level4">
                  <a href="bookmarks.html" class="level4 ">ä¹¦ç­¾</a>
            </li><li class="level4">
                  <a href="cookies.html" class="level4 ">Cookie</a>
            </li><li class="level4">
                  <a href="devtools.html" class="level4 ">æ‰©å±•å¼€å‘è€…å·¥å…·</a>
            </li><li class="level4">
                  <a href="events.html" class="level4 ">äº‹ä»¶</a>
            </li><li class="level4">
                  <a href="history.html" class="level4 ">å†å²è®°å½•</a>
            </li><li class="level4">
                  <a href="management.html" class="level4 ">ç®¡ç†</a>
            </li><li class="level4">
                  <a href="tabs.html" class="level4 ">æ ‡ç­¾é¡µ</a>
            </li><li class="level4">
                  <a href="windows.html" class="level4 ">çª—å£</a>
            </li>
            </ul>
          </li><li class="level3">
              <a class="button level3">
                <span class="level3">å®ç°</span>
                <div class="toggleIndicator level3 toggled"></div>
              </a>
            <ul toggleable
                class="level3 ">
            <li class="level4">
                  <a href="a11y.html" class="level4 ">è¾…åŠ©åŠŸèƒ½</a>
            </li><li class="level4">
                  <a href="event_pages.html" class="level4 ">äº‹ä»¶é¡µé¢</a>
            </li><li class="level4">
                  <a href="contentSecurityPolicy.html" class="level4 ">å†…å®¹å®‰å…¨ç­–ç•¥</a>
            </li><li class="level4">
                  <a href="content_scripts.html" class="level4 ">å†…å®¹è„šæœ¬</a>
            </li><li class="level4">
                  <a href="xhr.html" class="level4 ">è·¨ç«™ XHR</a>
            </li><li class="level4">
                  <a href="i18n.html" class="level4 ">å›½é™…åŒ–æ”¯æŒ</a>
            </li><li class="level4">
                  <a  class="level4 selected">æ¶ˆæ¯ä¼ é€’</a>
            </li><li class="level4">
                  <a href="permissions.html" class="level4 ">å¯é€‰æƒé™</a>
            </li><li class="level4">
                  <a href="npapi.html" class="level4 ">NPAPI æ’ä»¶</a>
            </li>
            </ul>
          </li><li class="level3">
              <a class="button level3">
                <span class="level3">å®Œæˆ</span>
                <div class="toggleIndicator level3"></div>
              </a>
            <ul toggleable
                class="level3 hidden">
            <li class="level4">
                  <a href="hosting.html" class="level4 ">æ‰˜ç®¡</a>
            </li><li class="level4">
                  <a href="external_extensions.html" class="level4 ">å…¶ä»–å‘å¸ƒé€‰é¡¹</a>
            </li>
            </ul>
          </li>
          </ul>
        </li><li class="level2">
              <a href="tutorials.html" class="level2 ">æ•™ç¨‹</a>
          <ul 
              class="level2 ">
          <li class="level3">
                <a href="tut_migration_to_manifest_v2.html" class="level3 ">æ¸…å•æ–‡ä»¶ç‰ˆæœ¬ 2</a>
          </li><li class="level3">
                <a href="tut_debugging.html" class="level3 ">è°ƒè¯•</a>
          </li><li class="level3">
                <a href="tut_analytics.html" class="level3 ">Google Analyticsï¼ˆåˆ†æï¼‰</a>
          </li><li class="level3">
                <a href="tut_oauth.html" class="level3 ">OAuth</a>
          </li>
          </ul>
        </li><li class="level2">
              <span class="level2">å‚è€ƒ</span>
          <ul 
              class="level2 ">
          <li class="level3">
              <a class="button level3">
                <span class="level3">æ ¼å¼</span>
                <div class="toggleIndicator level3"></div>
              </a>
            <ul toggleable
                class="level3 hidden">
            <li class="level4">
                  <a href="manifest.html" class="level4 ">æ¸…å•æ–‡ä»¶</a>
            </li><li class="level4">
                  <a href="match_patterns.html" class="level4 ">åŒ¹é…è¡¨è¾¾å¼</a>
            </li>
            </ul>
          </li><li class="level3">
                <a href="permission_warnings.html" class="level3 ">æƒé™è­¦å‘Š</a>
          </li><li class="level3">
                <a href="api_index.html" class="level3 ">chrome.* API</a>
          </li><li class="level3">
                <a href="api_other.html" class="level3 ">å…¶ä»– API</a>
          </li>
          </ul>
        </li><li class="level2">
              <span class="level2">æ›´å¤š</span>
          <ul 
              class="level2 ">
          <li class="level3">
                <a href="faq.html" class="level3 ">å¸¸è§é—®é¢˜</a>
          </li><li class="level3">
                <a href="http://code.google.com/chrome/webstore/docs/index.html" class="level3 ">Chrome ç½‘ä¸Šåº”ç”¨åº—</a>
          </li><li class="level3">
                <a href="http://code.google.com/chrome/apps/docs/developers_guide.html" class="level3 ">æ‰˜ç®¡åº”ç”¨</a>
          </li><li class="level3">
                <a href="themes.html" class="level3 ">ä¸»é¢˜èƒŒæ™¯</a>
          </li>
          </ul>
        </li>
        </ul>
      </div>
      <div id="gc-pagecontent">

<div id="toc">
  <ol>
    <li >
      <a href="#simple"
         data-list-item
         >ç®€å•çš„ä¸€æ¬¡æ€§è¯·æ±‚</a>
    </li>
    <li >
      <a href="#connect"
         data-list-item
         >é•¿æ—¶é—´çš„è¿æ¥</a>
    </li>
    <li >
      <a href="#external"
         data-list-item
         >è·¨æ‰©å±•ç¨‹åºæ¶ˆæ¯ä¼ é€’</a>
    </li>
    <li >
      <a href="#external-webpage"
         data-list-item
         >ä»ç½‘é¡µå‘é€æ¶ˆæ¯</a>
    </li>
    <li >
      <a href="#native-messaging"
         data-list-item
         >åŸç”Ÿæ¶ˆæ¯é€šä¿¡</a>
      <ol>
        <li >
          <a href="#native-messaging-host"
             data-list-item
             >åŸç”Ÿæ¶ˆæ¯é€šä¿¡å®¿ä¸»</a>
        </li>
        <li >
          <a href="#native-messaging-client"
             data-list-item
             >è¿æ¥åˆ°åŸç”Ÿåº”ç”¨ç¨‹åº</a>
        </li>
      </ol>
    </li>
    <li >
      <a href="#security-considerations"
         data-list-item
         >å®‰å…¨æ€§è€ƒè™‘</a>
    </li>
    <li >
      <a href="#examples"
         data-list-item
         >ä¾‹å­</a>
    </li>
  </ol>
</div>

<h1><!--@Message Passing-->æ¶ˆæ¯ä¼ é€’</h1>


<p>
<!--@Since content scripts run in the context of a web page and not the extension,
they often need some way of communicating with the rest of the extension. For
example, an RSS reader extension might use content scripts to detect the
presence of an RSS feed on a page, then notify the background page in order to
display a page action icon for that page.-->
ç”±äºå†…å®¹è„šæœ¬åœ¨ç½‘é¡µè€Œä¸æ˜¯æ‰©å±•ç¨‹åºçš„ç¯å¢ƒä¸­è¿è¡Œï¼Œå®ƒä»¬é€šå¸¸éœ€è¦æŸç§æ–¹å¼ä¸æ‰©å±•ç¨‹åºçš„å…¶ä½™éƒ¨åˆ†é€šä¿¡ã€‚ä¾‹å¦‚ï¼ŒRSS é˜…è¯»å™¨æ‰©å±•ç¨‹åºå¯èƒ½ä½¿ç”¨å†…å®¹è„šæœ¬æ£€æµ‹é¡µé¢ä¸Šæ˜¯å¦å­˜åœ¨ RSS ä¾›ç¨¿ï¼Œç„¶åé€šçŸ¥åå°é¡µé¢ï¼Œä¸ºå½“å‰é¡µé¢æ˜¾ç¤ºé¡µé¢æŒ‰é’®å›¾æ ‡ã€‚

<p>
<!--@Communication between extensions and their content scripts works by using
message passing. Either side can listen for messages sent from the other end,
and respond on the same channel. A message can contain any valid JSON object
(null, boolean, number, string, array, or object). There is a simple API for
<a href="#simple">one-time requests</a>
and a more complex API that allows you to have
<a href="#connect">long-lived connections</a>
for exchanging multiple messages with a shared context. It is also possible to
send a message to another extension if you know its ID, which is covered in
the
<a href="#external">cross-extension messages</a>
section.-->
æ‰©å±•ç¨‹åºå’Œå†…å®¹è„šæœ¬é—´çš„é€šä¿¡ä½¿ç”¨æ¶ˆæ¯ä¼ é€’çš„æ–¹å¼ã€‚ä¸¤è¾¹å‡å¯ä»¥ç›‘å¬å¦ä¸€è¾¹å‘æ¥çš„æ¶ˆæ¯ï¼Œå¹¶é€šè¿‡åŒæ ·çš„é€šé“å›åº”ã€‚æ¶ˆæ¯å¯ä»¥åŒ…å«ä»»ä½•æœ‰æ•ˆçš„
JSON å¯¹è±¡ï¼ˆnullã€booleanã€numberã€stringã€array æˆ– objectï¼‰ã€‚å¯¹äº<a
href="#simple">ä¸€æ¬¡æ€§çš„è¯·æ±‚</a>æœ‰ä¸€ä¸ªç®€å•çš„ APIï¼ŒåŒæ—¶ä¹Ÿæœ‰æ›´å¤æ‚çš„
APIï¼Œå…è®¸æ‚¨é€šè¿‡<a href="#connect"
>é•¿æ—¶é—´çš„è¿æ¥</a>ä¸å…±äº«çš„ä¸Šä¸‹æ–‡äº¤æ¢å¤šä¸ªæ¶ˆæ¯ã€‚å¦å¤–æ‚¨ä¹Ÿå¯ä»¥å‘å¦ä¸€ä¸ªæ‰©å±•ç¨‹åºå‘é€æ¶ˆæ¯ï¼Œåªè¦æ‚¨çŸ¥é“å®ƒçš„æ ‡è¯†ç¬¦ï¼Œè¿™å°†åœ¨<a
href="#external">è·¨æ‰©å±•ç¨‹åºæ¶ˆæ¯ä¼ é€’</a>éƒ¨åˆ†ä»‹ç»ã€‚


<h2 id="simple"><!--@Simple one-time requests-->ç®€å•çš„ä¸€æ¬¡æ€§è¯·æ±‚</h2>
<p>
<!--@If you only need to send a single message to another part of your extension
(and optionally get a response back), you should use the simplified
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-sendMessage">runtime.sendMessage</a>
or
<a href="https://crxdoc-zh.appspot.com/extensions/tabs.html#method-sendMessage">tabs.sendMessage</a>
methods. This lets you send a one-time JSON-serializable message from a
content script to extension, or vice versa, respectively. An optional
callback parameter allows you handle the response from the other side, if
there is one.-->
å¦‚æœæ‚¨åªéœ€è¦å‘æ‚¨çš„æ‰©å±•ç¨‹åºçš„å¦ä¸€éƒ¨åˆ†å‘é€ä¸€ä¸ªç®€å•æ¶ˆæ¯ï¼ˆä»¥åŠå¯é€‰åœ°è·å¾—å›åº”ï¼‰ï¼Œæ‚¨åº”è¯¥ä½¿ç”¨æ¯”è¾ƒç®€å•çš„
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-sendMessage">runtime.sendMessage</a> æˆ– <a href="https://crxdoc-zh.appspot.com/extensions/tabs.html#method-sendMessage">tabs.sendMessage</a>
æ–¹æ³•ã€‚è¿™äº›æ–¹æ³•åˆ†åˆ«è®©æ‚¨ä»å†…å®¹è„šæœ¬å‘æ‰©å±•ç¨‹åºæˆ–è€…åè¿‡æ¥å‘é€ä¸€ä¸ªå¯ä»¥é€šè¿‡ JSON
åºåˆ—åŒ–çš„æ¶ˆæ¯ï¼Œå¯é€‰çš„ callback å‚æ•°å…è®¸æ‚¨åœ¨éœ€è¦çš„æ—¶å€™ä»å¦ä¸€è¾¹å¤„ç†å›åº”ã€‚

<p>
<!--@Sending a request from a content script looks like this:-->
å¦‚ä¸‹åˆ—ä»£ç æ‰€ç¤ºä»å†…å®¹è„šæœ¬ä¸­å‘é€è¯·æ±‚ï¼š
<pre data-filename="contentscript.js">
chrome.runtime.sendMessage({greeting: "æ‚¨å¥½"}, function(response) {
  console.log(response.farewell);
});
</pre>

<p>
<!--@Sending a request from the extension to a content script looks very similar,
except that you need to specify which tab to send it to. This example
demonstrates sending a message to the content script in the selected tab.-->
ä»æ‰©å±•ç¨‹åºå‘å†…å®¹è„šæœ¬å‘é€è¯·æ±‚ä¸ä¸Šé¢ç±»ä¼¼ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯æ‚¨éœ€è¦æŒ‡å®šå‘é€è‡³å“ªä¸€ä¸ªæ ‡ç­¾é¡µã€‚è¿™ä¸€ä¾‹å­æ¼”ç¤ºå¦‚ä½•å‘é€‰å®šæ ‡ç­¾é¡µä¸­çš„å†…å®¹è„šæœ¬å‘é€æ¶ˆæ¯ã€‚
<pre data-filename="background.html">
chrome.tabs.query({active: true, currentWindow: true}, function(tabs) {
  chrome.tabs.sendMessage(tabs[0].id, {greeting: "æ‚¨å¥½"}, function(response) {
    console.log(response.farewell);
  });
});
</pre>

<p>
<!--@On the receiving end, you need to set up an
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#event-onMessage">runtime.onMessage</a>
event listener to handle the message. This looks the same from a content
script or extension page.-->
åœ¨æ¥æ”¶ç«¯ï¼Œæ‚¨éœ€è¦è®¾ç½®ä¸€ä¸ª <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#event-onMessage">runtime.onMessage</a> äº‹ä»¶ç›‘å¬å™¨æ¥å¤„ç†æ¶ˆæ¯ã€‚
<pre>
chrome.runtime.onMessage.addListener(
  function(request, sender, sendResponse) {
    console.log(sender.tab ?
                "æ¥è‡ªå†…å®¹è„šæœ¬ï¼š" + sender.tab.url :
                "æ¥è‡ªæ‰©å±•ç¨‹åº");
    if (request.greeting == "æ‚¨å¥½")
      sendResponse({farewell: "å†è§"});
  });
</pre>

<p class="note">
<b><!--@Note:-->æ³¨æ„ï¼š</b><!--@ If multiple pages are listening for onMessage events, only the
first to call sendResponse() for a particular event will succeed in sending the
response. All other responses to that event will be ignored.-->
å¦‚æœå¤šä¸ªé¡µé¢éƒ½ç›‘å¬ onMessage äº‹ä»¶ï¼Œå¯¹äºæŸä¸€æ¬¡äº‹ä»¶åªæœ‰ç¬¬ä¸€æ¬¡è°ƒç”¨ sendResponse() èƒ½æˆåŠŸå‘å‡ºå›åº”ï¼Œæ‰€æœ‰å…¶ä»–å›åº”å°†è¢«å¿½ç•¥ã€‚
</p>


<h2 id="connect"><!--@Long-lived connections-->é•¿æ—¶é—´çš„è¿æ¥</h2>
<p>
<!--@Sometimes it's useful to have a conversation that lasts longer than a single
request and response. In this case, you can open a long-lived channel from
your content script to an extension page, or vice versa, using
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-connect">runtime.connect</a>
or
<a href="https://crxdoc-zh.appspot.com/extensions/tabs.html#method-connect">tabs.connect</a> respectively. The
channel can optionally have a name, allowing you to distinguish between
different types of connections.-->
æœ‰æ—¶å€™éœ€è¦é•¿æ—¶é—´çš„å¯¹è¯ï¼Œè€Œä¸æ˜¯ä¸€æ¬¡è¯·æ±‚å’Œå›åº”ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‚¨å¯ä»¥åˆ†åˆ«ä½¿ç”¨
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-connect">runtime.connect</a> æˆ– <a href="https://crxdoc-zh.appspot.com/extensions/tabs.html#method-connect">tabs.connect</a>
ä»æ‚¨çš„å†…å®¹è„šæœ¬å»ºç«‹åˆ°æ‰©å±•ç¨‹åºï¼ˆæˆ–è€…åè¿‡æ¥ï¼‰çš„é•¿æ—¶é—´è¿æ¥ã€‚å»ºç«‹çš„é€šé“å¯ä»¥æœ‰ä¸€ä¸ªå¯é€‰çš„åç§°ï¼Œè®©æ‚¨åŒºåˆ†ä¸åŒç±»å‹çš„è¿æ¥ã€‚

<p>
<!--@One use case might be an automatic form fill extension. The content script
could open a channel to the extension page for a particular login, and send a
message to the extension for each input element on the page to request the
form data to fill in. The shared connection allows the extension to keep
shared state linking the several messages coming from the content script.-->
ä½¿ç”¨é•¿æ—¶é—´è¿æ¥çš„ä¸€ç§å¯èƒ½çš„æƒ…å½¢ä¸ºè‡ªåŠ¨å¡«å……è¡¨å•çš„æ‰©å±•ç¨‹åºã€‚å¯¹äºä¸€æ¬¡ç™»å½•æ“ä½œï¼Œå†…å®¹è„šæœ¬å¯ä»¥è¿æ¥åˆ°æ‰©å±•ç¨‹åºé¡µé¢ï¼Œæ¯æ¬¡é¡µé¢ä¸Šçš„è¾“å…¥å…ƒç´ éœ€è¦å¡«å†™è¡¨å•æ•°æ®æ—¶å‘æ‰©å±•ç¨‹åºå‘é€æ¶ˆæ¯ã€‚å…±äº«çš„è¿æ¥å…è®¸æ‰©å±•ç¨‹åºä¿ç•™æ¥è‡ªå†…å®¹è„šæœ¬çš„ä¸åŒæ¶ˆæ¯ä¹‹é—´çš„çŠ¶æ€è”ç³»ã€‚

<p>
<!--@When establishing a connection, each end is given a
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#type-Port">runtime.Port</a>
object which is used for sending and receiving messages through that
connection.-->
å»ºç«‹è¿æ¥æ—¶ï¼Œä¸¤ç«¯éƒ½å°†è·å¾—ä¸€ä¸ª <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#type-Port">runtime.Port</a>
å¯¹è±¡ï¼Œç”¨æ¥é€šè¿‡å»ºç«‹çš„è¿æ¥å‘é€å’Œæ¥æ”¶æ¶ˆæ¯ã€‚

<p>
<!--@Here is how you open a channel from a content script, and send and listen for
messages:-->
å¦‚ä¸‹ä»£ç æ¼”ç¤ºå¦‚ä½•ä»å†…å®¹è„šæœ¬ä¸­å»ºç«‹è¿æ¥ï¼Œå‘é€å¹¶ç›‘å¬æ¶ˆæ¯ï¼š
<pre data-filename="contentscript.js">
var port = chrome.runtime.connect({name: "æ•²é—¨"});
port.postMessage({joke: "æ•²é—¨"});
port.onMessage.addListener(function(msg) {
  if (msg.question == "æ˜¯è°ï¼Ÿ")
    port.postMessage({answer: "å¥³å£«"});
  else if (msg.question == "å“ªä½å¥³å£«ï¼Ÿ")
    port.postMessage({answer: "Bovary å¥³å£«"});
});
</pre>

<p>
<!--@Sending a request from the extension to a content script looks very similar,
except that you need to specify which tab to connect to. Simply replace the
call to connect in the above example with
<a href="https://crxdoc-zh.appspot.com/extensions/tabs.html#method-connect">tabs.connect</a>.-->
ä»æ‰©å±•ç¨‹åºå‘å†…å®¹è„šæœ¬å‘é€è¯·æ±‚ä¸ä¹‹ç±»ä¼¼ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯æ‚¨éœ€è¦æŒ‡å®šè¿æ¥åˆ°å“ªä¸€ä¸ªæ ‡ç­¾é¡µã€‚æ‚¨åªéœ€è¦å°†ä»¥ä¸Šä¾‹å­ä¸­çš„è¿æ¥è°ƒç”¨æ›¿æ¢ä¸º
<a href="https://crxdoc-zh.appspot.com/extensions/tabs.html#method-connect">tabs.connect</a>ã€‚

<p>
<!--@In order to handle incoming connections, you need to set up a
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#event-onConnect">runtime.onConnect</a>
event listener. This looks the same from a content script or an extension
page. When another part of your extension calls "connect()", this event is
fired, along with the
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#type-Port">runtime.Port</a>
object you can use to send and receive messages through the connection. Here's
what it looks like to respond to incoming connections:-->
ä¸ºäº†å¤„ç†ä¼ å…¥è¿æ¥ï¼Œæ‚¨éœ€è¦è®¾ç½®ä¸€ä¸ª <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#event-onConnect">runtime.onConnect</a>
äº‹ä»¶ç›‘å¬å™¨ã€‚è¿™ä¸€æ­¥æ— è®ºåœ¨å†…å®¹è„šæœ¬è¿˜æ˜¯æ‰©å±•ç¨‹åºé¡µé¢ä¸­éƒ½æ˜¯ä¸€æ ·çš„ã€‚å½“æ‚¨çš„æ‰©å±•ç¨‹åºçš„å¦ä¸€éƒ¨åˆ†è°ƒç”¨
connect()
æ—¶ï¼Œä¼šäº§ç”Ÿè¿™ä¸€äº‹ä»¶ï¼ŒåŒæ—¶ä¼ é€’æ‚¨å¯ä»¥é€šè¿‡å»ºç«‹çš„è¿æ¥å‘é€å’Œæ¥å—æ¶ˆæ¯çš„
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#type-Port">runtime.Port</a> å¯¹è±¡ã€‚å¦‚ä¸‹ä»£ç æ¼”ç¤ºå¦‚ä½•å›åº”ä¼ å…¥è¿æ¥ï¼š
<pre>
chrome.runtime.onConnect.addListener(function(port) {
  console.assert(port.name == "æ•²é—¨");
  port.onMessage.addListener(function(msg) {
    if (msg.joke == "æ•²é—¨")
      port.postMessage({question: "æ˜¯è°ï¼Ÿ"});
    else if (msg.answer == "å¥³å£«")
      port.postMessage({question: "å“ªä½å¥³å£«ï¼Ÿ"});
    else if (msg.answer == "Bovary å¥³å£«")
      port.postMessage({question: "æˆ‘æ²¡å¬æ¸…æ¥šã€‚"});
  });
});
</pre>

<p>
<!--@You may want to find out when a connection is closed, for example if you are
maintaining separate state for each open port. For this you can listen to the
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#property-Port-onDisconnect">runtime.Port.onDisconnect</a>
event. This event is fired either when the other side of the channel manually
calls
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#property-Port-disconnect">runtime.Port.disconnect</a>, or when the page
containing the port is unloaded (for example if the tab is navigated).
onDisconnect is guaranteed to be fired only once for any given port.-->
æ‚¨å¯èƒ½æƒ³çŸ¥é“è¿æ¥ä½•æ—¶å…³é—­ï¼Œä¾‹å¦‚æ‚¨éœ€è¦ä¸ºæ¯ä¸€ä¸ªæ‰“å¼€çš„ç«¯å£å•ç‹¬ä¿ç•™çŠ¶æ€ã€‚è¿™ç§æƒ…å†µä¸‹æ‚¨å¯ä»¥ç›‘å¬
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#property-Port-onDisconnect">runtime.Port.onDisconnect</a> äº‹ä»¶ï¼Œå½“è¿æ¥çš„å¦ä¸€ç«¯è°ƒç”¨
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#property-Port-disconnect">runtime.Port.disconnect</a> æˆ–åŒ…å«è¯¥ç«¯å£çš„é¡µé¢å·²ç»“æŸï¼ˆä¾‹å¦‚æ ‡ç­¾é¡µè½¬åˆ°äº†å¦ä¸€ä¸ªé¡µé¢ï¼‰æ—¶ï¼Œå¯¹äºæ¯ä¸€ä¸ªç«¯å£ç¡®ä¿éƒ½ä¼šå‘ç”Ÿä¸€æ¬¡è¯¥äº‹ä»¶ã€‚


<h2 id="external"><!--@Cross-extension messaging-->è·¨æ‰©å±•ç¨‹åºæ¶ˆæ¯ä¼ é€’</h2>
<p>
<!--@In addition to sending messages between different components in your
extension, you can use the messaging API to communicate with other extensions.
This lets you expose a public API that other extensions can take advantage of.-->
é™¤äº†åœ¨æ‚¨çš„æ‰©å±•ç¨‹åºçš„ä¸åŒç»„æˆéƒ¨åˆ†é—´å‘é€æ¶ˆæ¯ä»¥å¤–ï¼Œæ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨æ¶ˆæ¯ä¼ é€’ API
ä¸å…¶ä»–æ‰©å±•ç¨‹åºé€šä¿¡ã€‚è¿™æ ·æ‚¨å¯ä»¥æä¾›ä¸€ä¸ªå…¬å…±çš„ APIï¼Œè®©å…¶ä»–æ‰©å±•ç¨‹åºä½¿ç”¨ã€‚

<p>
<!--@Listening for incoming requests and connections is similar to the internal
case, except you use the
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#event-onMessageExternal">runtime.onMessageExternal</a>
or
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#event-onConnectExternal">runtime.onConnectExternal</a>
methods. Here's an example of each:-->
ç›‘å¬ä¼ å…¥çš„è¯·æ±‚å’Œè¿æ¥ä¸å¤„ç†å†…éƒ¨çš„æ¶ˆæ¯ç±»ä¼¼ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯æ‚¨åˆ†åˆ«ä½¿ç”¨
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#event-onMessageExternal">runtime.onMessageExternal</a> å’Œ <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#event-onConnectExternal">runtime.onConnectExternal</a>
äº‹ä»¶ã€‚å¦‚ä¸‹æ˜¯åˆ†åˆ«å¤„ç†è¿™ä¸¤ä¸ªäº‹ä»¶çš„ä¾‹å­ï¼š
<pre>
// ç”¨äºç®€å•çš„è¯·æ±‚ï¼š
chrome.runtime.onMessageExternal.addListener(
  function(request, sender, sendResponse) {
    if (sender.id == blacklistedExtension)
      return;  // ä¸å…è®¸è¿™ä¸€æ‰©å±•ç¨‹åºè®¿é—®
    else if (request.getTargetData)
      sendResponse({targetData: targetData});
    else if (request.activateLasers) {
      var success = activateLasers();
      sendResponse({activateLasers: success});
    }
  });

// ç”¨äºé•¿æ—¶é—´çš„è¿æ¥ï¼š
chrome.runtime.onConnectExternal.addListener(function(port) {
  port.onMessage.addListener(function(msg) {
    // æœ‰å…³å¤„ç† onMessage äº‹ä»¶çš„ç¤ºä¾‹è¯·å‚è§å…¶ä»–ä¾‹å­
  });
});
</pre>

<p>
<!--@Likewise, sending a message to another extension is similar to sending one
within your extension. The only difference is that you must pass the ID of the
extension you want to communicate with. For example:-->
åŒæ ·ï¼Œå‘å¦ä¸€ä¸ªæ‰©å±•ç¨‹åºå‘é€æ¶ˆæ¯ä¸åœ¨æ‚¨çš„æ‰©å±•ç¨‹åºä¸­å‘é€æ¶ˆæ¯ç±»ä¼¼ï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯æ‚¨å¿…é¡»ä¼ é€’æ‚¨éœ€è¦ä¸ä¹‹é€šä¿¡çš„æ‰©å±•ç¨‹åºçš„æ ‡è¯†ç¬¦ã€‚ä¾‹å¦‚ï¼š
<pre>
// æˆ‘ä»¬éœ€è¦ä¸ä¹‹é€šä¿¡çš„æ‰©å±•ç¨‹åºçš„æ ‡è¯†ç¬¦ã€‚
var laserExtensionId = "abcdefghijklmnoabcdefhijklmnoabc";

// å‘å‡ºä¸€ä¸ªç®€å•è¯·æ±‚ï¼š
chrome.runtime.sendMessage(laserExtensionId, {getTargetData: true},
  function(response) {
    if (targetInRange(response.targetData))
      chrome.runtime.sendMessage(laserExtensionId, {activateLasers: true});
  });

// å»ºç«‹ä¸€ä¸ªé•¿æ—¶é—´çš„è¿æ¥ï¼š
var port = chrome.runtime.connect(laserExtensionId);
port.postMessage(...);
</pre>


<h2 id="external-webpage"><!--@Sending messages from web pages-->ä»ç½‘é¡µå‘é€æ¶ˆæ¯</h2>
<p>
<!--@Similar to <a href="#external">cross-extension messaging</a>,
your app or extension can receive and
respond to messages from regular web pages.
To use this feature, you must first
specify in your manifest.json which web sites you want to communicate with. For
example:-->
ä¸<a href="#external"
>è·¨æ‰©å±•ç¨‹åºæ¶ˆæ¯ä¼ é€’</a>ç±»ä¼¼ï¼Œæ‚¨çš„åº”ç”¨æˆ–æ‰©å±•ç¨‹åºå¯ä»¥æ¥å—å¹¶å“åº”æ¥è‡ªæ™®é€šç½‘é¡µçš„æ¶ˆæ¯ã€‚è¦ä½¿ç”¨è¯¥ç‰¹æ€§ï¼Œæ‚¨å¿…é¡»é¦–å…ˆåœ¨æ‚¨çš„
manifest.json ä¸­æŒ‡å®šæ‚¨å¸Œæœ›ä¸ä¹‹é€šä¿¡çš„ç½‘ç«™ï¼Œä¾‹å¦‚ï¼š

<pre data-filename="manifest.json">
"externally_connectable": {
  "matches": ["*://*.example.com/*"]
}
</pre>

<p>
<!--@This will expose the messaging API to any page which matches the URL patterns
you specify. The URL pattern must contain at least a
<a href="http://en.wikipedia.org/wiki/Second-level_domain">second-level domain</a>
- that is, hostname
patterns like "*", "*.com", "*.co.uk", and "*.appspot.com" are prohibited.
From the web page, use the
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-sendMessage">runtime.sendMessage</a>
or
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-connect">runtime.connect</a>
APIs to send a message to a specific app or extension. For example:-->
è¿™æ ·ä¼šå°†æ¶ˆæ¯ä¼ é€’ API æä¾›ç»™æ‰€æœ‰åŒ¹é…æ‚¨æŒ‡å®šçš„ URL
è¡¨è¾¾å¼çš„ç½‘é¡µã€‚URL è¡¨è¾¾å¼å¿…é¡»è‡³å°‘åŒ…å«ä¸€ä¸ª<a
href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E7%BA%A7%E5%9F%9F"
>äºŒçº§åŸŸå</a>ï¼Œä¹Ÿå°±æ˜¯è¯´ç¦æ­¢ä½¿ç”¨ç±»ä¼¼äºâ€œ*â€ã€â€œ*.comâ€ã€â€œ*.co.ukâ€å’Œâ€œ*.appspot.comâ€ä¹‹ç±»çš„ä¸»æœºåã€‚åœ¨ç½‘é¡µä¸­ï¼Œä½¿ç”¨ <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-sendMessage">runtime.sendMessage</a> æˆ– <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-connect">runtime.connect</a> API å‘æŒ‡å®šåº”ç”¨æˆ–æ‰©å±•ç¨‹åºå‘é€æ¶ˆæ¯ã€‚ä¾‹å¦‚ï¼š
<pre>
// æˆ‘ä»¬å¸Œæœ›ä¸ä¹‹é€šä¿¡çš„æ‰©å±•ç¨‹åºæ ‡è¯†ç¬¦ã€‚
var editorExtensionId = "abcdefghijklmnoabcdefhijklmnoabc";

// å‘é€ä¸€ä¸ªç®€å•çš„è¯·æ±‚ï¼š
chrome.runtime.sendMessage(editorExtensionId, {openUrlInEditor: url},
  function(response) {
    if (!response.success)
      handleError(url);
  });
</pre>

<p>
<!--@From your app or extension, you may listen to messages from web pages via the
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#event-onMessageExternal">runtime.onMessageExternal</a>
or
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#event-onConnectExternal">runtime.onConnectExternal</a>
APIs, similar to <a href="#external">cross-extension messaging</a>.
Only the web page can initiate a connection.
Here is an example:-->
åœ¨æ‚¨çš„åº”ç”¨æˆ–æ‰©å±•ç¨‹åºä¸­ï¼Œæ‚¨å¯ä»¥é€šè¿‡ <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#event-onMessageExternal">runtime.onMessageExternal</a> æˆ–
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#event-onConnectExternal">runtime.onConnectExternal</a> API ç›‘å¬æ¥è‡ªç½‘é¡µçš„æ¶ˆæ¯ï¼Œä¸<a href="#external"
>è·¨æ‰©å±•ç¨‹åºæ¶ˆæ¯ä¼ é€’</a>ç±»ä¼¼ã€‚åªæœ‰ç½‘é¡µæ‰èƒ½å‘èµ·è¿æ¥ã€‚å¦‚ä¸‹æ˜¯ä¸€ä¸ªä¾‹å­ï¼š

<pre>
chrome.runtime.onMessageExternal.addListener(
  function(request, sender, sendResponse) {
    if (sender.url == blacklistedWebsite)
      return;  // ä¸å…è®¸è¯¥ç½‘é¡µè®¿é—®
    if (request.openUrlInEditor)
      openUrl(request.openUrlInEditor);
  });
</pre>


<h2 id="native-messaging"><!--@Native messaging-->åŸç”Ÿæ¶ˆæ¯é€šä¿¡</h2>
<p>
<!--@Extensions can exchange messages with native applications. Native
applications that support this feature must register a <em>native messaging
host</em> that knows how to communicate with the extension. Chrome starts the
host in a separate process and communicates with it using standard input and
standard output streams.-->
æ‰©å±•ç¨‹åºå¯ä»¥ä¸åŸç”Ÿåº”ç”¨ç¨‹åºäº¤æ¢æ¶ˆæ¯ã€‚æ”¯æŒè¯¥ç‰¹æ€§çš„åŸç”Ÿåº”ç”¨ç¨‹åºå¿…é¡»æ³¨å†Œä¸€ä¸ªäº†è§£å¦‚ä½•ä¸æ‰©å±•ç¨‹åºé€šä¿¡çš„<em
>åŸç”Ÿæ¶ˆæ¯å®¿ä¸»</em>ï¼ŒChrome æµè§ˆå™¨å°†åœ¨å•ç‹¬çš„è¿›ç¨‹ä¸­å¯åŠ¨å®¿ä¸»ï¼Œå¹¶é€šè¿‡æ ‡å‡†è¾“å…¥å’Œæ ‡å‡†è¾“å‡ºæµä¸ä¹‹é€šä¿¡ã€‚

<h3 id="native-messaging-host"><!--@Native messaging host-->åŸç”Ÿæ¶ˆæ¯é€šä¿¡å®¿ä¸»</h3>
<p>
<!--@In order to register a native messaging host the application must install a
manifest file that defines the native messaging host configuration. Below is an
example of the manifest file:-->
ä¸ºäº†æ³¨å†Œä¸€ä¸ªåŸç”Ÿæ¶ˆæ¯é€šä¿¡å®¿ä¸»ï¼Œåº”ç”¨ç¨‹åºå¿…é¡»å®‰è£…ä¸€ä¸ªæ¸…å•æ–‡ä»¶ï¼Œå®šä¹‰åŸç”Ÿæ¶ˆæ¯é€šä¿¡å®¿ä¸»çš„é…ç½®ã€‚å¦‚ä¸‹æ˜¯è¿™ä¸€æ¸…å•æ–‡ä»¶çš„ä¾‹å­ï¼š
<pre data-filename="manifest.json">
{
  "name": "com.my_company.my_application",
  "description": "æˆ‘çš„åº”ç”¨ç¨‹åº",
  "path": "C:\\Program Files\\My Application\\chrome_native_messaging_host.exe",
  "type": "stdio",
  "allowed_origins": [
    "chrome-extension://knldjmfmopnpolahpmmgbagdohdnhkik/"
  ]
}
</pre>

<p><!--@Native messaging host manifest file contains the following fields:-->
æ¶ˆæ¯é€šä¿¡å®¿ä¸»æ¸…å•æ–‡ä»¶åŒ…å«å¦‚ä¸‹å­—æ®µï¼š
<table class="simple">
  <tr>
    <th><!--@Name-->åç§°</th>
    <th><!--@Description-->æè¿°</th>
  </tr>
  <tr>
    <td><code>name</code></td>
    <td><!--@Name of the native messaging host. Clients pass this string to
    <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-connectNative">runtime.connectNative</a> or <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-sendNativeMessage">runtime.sendNativeMessage</a>.-->
    åŸç”Ÿæ¶ˆæ¯é€šä¿¡å®¿ä¸»çš„åç§°ï¼Œå®¢æˆ·ç«¯éœ€è¦å°†è¯¥å­—ç¬¦ä¸²ä¼ é€’ç»™
    <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-connectNative">runtime.connectNative</a> æˆ– <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-sendNativeMessage">runtime.sendNativeMessage</a>ã€‚
    </td>
  </tr>
  <tr>
    <td><code>description</code></td>
    <td><!--@Short application description.-->åº”ç”¨ç¨‹åºçš„ç®€çŸ­æè¿°ã€‚</td>
  </tr>
  <tr>
    <td><code>path</code></td>
    <td><!--@Path to the native messaging host binary. On Linux and OSX the path must
    be absolute. On Windows it can be relative to the directory in which the
    manifest file is located.-->
      åŸç”Ÿæ¶ˆæ¯é€šä¿¡å®¿ä¸»çš„äºŒè¿›åˆ¶æ–‡ä»¶è·¯å¾„ã€‚åœ¨ Linux å’Œ OSX
      ä¸Šå¿…é¡»ä½¿ç”¨ç»å¯¹è·¯å¾„ï¼Œåœ¨ Windows
      ä¸Šå¯ä»¥ä½¿ç”¨ç›¸å¯¹äºæ¸…å•æ–‡ä»¶æ‰€åœ¨ç›®å½•çš„è·¯å¾„ã€‚
    </td>
  </tr>
  <tr>
    <td><code>type</code></td>
    <td><!--@Type of the interface used to communicate with the native messaging
    host. Currently there is only one possible value for this parameter:
    <code>stdio</code>. It indicates that Chrome should use <code>stdin</code>
    and <code>stdout</code> to communicate with the host.-->
    ä¸åŸç”Ÿæ¶ˆæ¯é€šä¿¡å®¿ä¸»äº¤æµæ—¶æ‰€ä½¿ç”¨çš„æ¥å£ç±»å‹ã€‚ç›®å‰è¯¥å‚æ•°åªæœ‰ä¸€ç§å¯èƒ½çš„å€¼ï¼š<code
    >stdio</code>ï¼Œå®ƒè¡¨ç¤º Chrome æµè§ˆå™¨åº”è¯¥ä½¿ç”¨
    <code>stdin</code>ï¼ˆæ ‡å‡†è¾“å…¥ï¼‰å’Œ
    <code>stdout</code>ï¼ˆæ ‡å‡†è¾“å‡ºï¼‰ä¸å®¿ä¸»é€šä¿¡ã€‚
    </td>
  </tr>
  <tr>
    <td><code>allowed_origins</code></td>
    <td><!--@List of extensions that should have access to the native messaging host.-->
    å…è®¸è®¿é—®åŸç”Ÿæ¶ˆæ¯é€šä¿¡å®¿ä¸»çš„æ‰©å±•ç¨‹åºåˆ—è¡¨ã€‚
    </td>
  </tr>
</table>

<p><!--@Location of the manifest file depends on the platform:-->
æ¸…å•æ–‡ä»¶çš„ç±»å‹å–å†³ä¸å¹³å°ï¼š

<dl>
  <dt>Windows<!--@:-->ï¼š</dt>
    <dd><!--@The manifest file can be located anywhere in the file system.
     The application installer must create registry key-->
     æ¸…å•æ–‡ä»¶å¯ä»¥åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­çš„ä»»æ„ä½ç½®ï¼Œåº”ç”¨ç¨‹åºçš„å®‰è£…ç¨‹åºå¿…é¡»åˆ›å»ºå¦‚ä¸‹æ³¨å†Œè¡¨é”®
     <code>HKEY_LOCAL_MACHINE\SOFTWARE\Google\Chrome\NativeMessagingHosts\<em>com.my_company.my_application</em></code><!--
     and set default value of that key to the full path to the manifest file.-->ï¼Œå¹¶å°†é”®çš„é»˜è®¤å€¼è®¾ç½®ä¸ºæ¸…å•æ–‡ä»¶çš„å®Œæ•´è·¯å¾„ã€‚
    </dd>

  <dt>OSX<!--@:-->ï¼š</dt>
    <dd><!--@The manifest file must be placed at-->
    æ¸…å•æ–‡ä»¶å¿…é¡»ä½äº
    <code>/Library/Google/Chrome/NativeMessagingHosts/<em>com.my_company.my_application</em>.json</code>
    </dd>
  <dt>Linux<!--@:-->ï¼š</dt>
    <dd><!--@The manifest file must be placed at-->
    æ¸…å•æ–‡ä»¶å¿…é¡»ä½äº
    <code>/etc/opt/chrome/native-messaging-hosts/<em>com.my_company.my_application</em>.json</code>
    </dd>
</dl>

<p>
<!--@Chrome starts each native messaging host in a separate process and communicates
with it using standard input (<code>stdin</code>) and standard output
(<code>stdout</code>). The same format is used to send messages in both
directions: each message is serialized using JSON, UTF-8 encoded
and is preceded with 32-bit message length in native byte order.-->
Chrome æµè§ˆå™¨åœ¨å•ç‹¬çš„è¿›ç¨‹ä¸­å¯åŠ¨æ¯ä¸€ä¸ªåŸç”Ÿæ¶ˆæ¯é€šä¿¡å®¿ä¸»ï¼Œå¹¶ä½¿ç”¨æ ‡å‡†è¾“å…¥ï¼ˆ<code
>stdin</code>ï¼‰ä¸æ ‡å‡†è¾“å‡ºï¼ˆ<code>stdout</code>ï¼‰ä¸ä¹‹é€šä¿¡ã€‚å‘ä¸¤ä¸ªæ–¹å‘å‘é€æ¶ˆæ¯æ—¶ä½¿ç”¨ç›¸åŒçš„æ ¼å¼ï¼šæ¯ä¸€æ¡æ¶ˆæ¯ä½¿ç”¨
JSON åºåˆ—åŒ–ï¼Œä»¥ UTF-8 ç¼–ç ï¼Œå¹¶åœ¨å‰é¢é™„åŠ  32 ä½çš„æ¶ˆæ¯é•¿åº¦ï¼ˆä½¿ç”¨æœ¬æœºå­—èŠ‚é¡ºåºï¼‰ã€‚

<p>
<!--@When a messaging port is created using <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-connectNative">runtime.connectNative</a> Chrome
starts native messaging host process and keeps it running until the port is
destroyed. On the other hand, when a message is sent using
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-sendNativeMessage">runtime.sendNativeMessage</a>, without creating a messaging port, Chrome starts
a new native messaging host process for each message. In that case the first
message generated by the host process is handled as a response to the original
request, i.e. Chrome will pass it to the response callback specified when
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-sendNativeMessage">runtime.sendNativeMessage</a> is called. All other messages generated by the
native messaging host in that case are ignored.-->
ä½¿ç”¨ <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-connectNative">runtime.connectNative</a> åˆ›å»ºæ¶ˆæ¯ä¼ é€’ç«¯å£æ—¶ï¼ŒChrome
æµè§ˆå™¨ä¼šå¯åŠ¨åŸç”Ÿæ¶ˆæ¯ä¼ é€’å®¿ä¸»è¿›ç¨‹ï¼Œå¹¶è®©å®ƒä¸€ç›´è¿è¡Œï¼Œç›´åˆ°ç«¯å£é‡Šæ”¾ã€‚å¦‚æœæ¶ˆæ¯æ˜¯ä½¿ç”¨
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-sendNativeMessage">runtime.sendNativeMessage</a> å‘é€ï¼Œæ²¡æœ‰åˆ›å»ºæ¶ˆæ¯ä¼ é€’ç«¯å£ï¼ŒChrome
æµè§ˆå™¨ä¼šä¸ºæ¯ä¸€æ¡æ¶ˆæ¯åˆ›å»ºä¸€ä¸ªæ–°çš„åŸç”Ÿæ¶ˆæ¯ä¼ é€’å®¿ä¸»è¿›ç¨‹ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œå®¿ä¸»è¿›ç¨‹äº§ç”Ÿçš„ç¬¬ä¸€æ¡æ¶ˆæ¯ä½œä¸ºåŸå§‹è¯·æ±‚çš„å“åº”å¤„ç†ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼ŒChrome
æµè§ˆå™¨ä¼šå°†å®ƒä¼ é€’ç»™è°ƒç”¨ <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-sendNativeMessage">runtime.sendNativeMessage</a>
æ—¶æŒ‡å®šçš„å›è°ƒå‡½æ•°ï¼Œè€ŒåŸç”Ÿæ¶ˆæ¯ä¼ é€’å®¿ä¸»äº§ç”Ÿçš„æ‰€æœ‰å…¶ä»–æ¶ˆæ¯åˆ™ä¼šå¿½ç•¥ã€‚

<h3 id="native-messaging-client"><!--@Connecting to a native application-->è¿æ¥åˆ°åŸç”Ÿåº”ç”¨ç¨‹åº</h3>
<p>
<!--@Sending and receiving messages to and from a native application is very similar
to cross-extension messaging. The main difference is that
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-connectNative">runtime.connectNative</a> is used instead of <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-connect">runtime.connect</a>,
and <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-sendNativeMessage">runtime.sendNativeMessage</a> is used instead of <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-sendMessage">runtime.sendMessage</a>.-->
å‘åŸç”Ÿåº”ç”¨ç¨‹åºå‘é€å’Œæ¥æ”¶æ¶ˆæ¯ç±»ä¼¼ä¸è·¨æ‰©å±•ç¨‹åºæ¶ˆæ¯ä¼ é€’ï¼Œä¸»è¦çš„åŒºåˆ«æ˜¯ç”¨
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-connectNative">runtime.connectNative</a> ä»£æ›¿ <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-connect">runtime.connect</a>ï¼Œç”¨
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-sendNativeMessage">runtime.sendNativeMessage</a> ä»£æ›¿ <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-sendMessage">runtime.sendMessage</a>ã€‚
<p>
<!--@The Following example creates a <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#type-Port">runtime.Port</a> object that's connected to native
messaging host <code>com.my_company.my_application</code>, starts listening for
messages from that port and sends one outgoing message:-->
ä»¥ä¸‹ä¾‹å­åˆ›å»ºä¸€ä¸ª <a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#type-Port">runtime.Port</a> å¯¹è±¡ï¼Œè¿æ¥åˆ°åŸç”Ÿæ¶ˆæ¯é€šä¿¡å®¿ä¸»
<code>com.my_company.my_application</code>ï¼Œå¼€å§‹ç›‘å¬æ¥è‡ªè¯¥ç«¯å£çš„æ¶ˆæ¯ï¼Œå¹¶å‘é€ä¸€æ¡æ¶ˆæ¯ï¼š
<pre>
var port = chrome.runtime.connectNative('com.my_company.my_application');
port.onMessage.addListener(function(msg) {
  console.log("æ”¶åˆ° " + msg);
});
port.onDisconnect.addListener(function() {
  console.log("å·²æ–­å¼€");
});
port.postMessage({ text: "æˆ‘çš„åº”ç”¨ç¨‹åºï¼Œæ‚¨å¥½ï¼" });
</pre>

<p>
<a href="https://crxdoc-zh.appspot.com/extensions/runtime.html#method-sendNativeMessage">runtime.sendNativeMessage</a> <!--@can be used to send a message to native
application without creating a port, e.g.:-->
å¯ä»¥ç”¨æ¥å‘åŸç”Ÿåº”ç”¨ç¨‹åºå‘é€æ¶ˆæ¯ï¼Œè€Œä¸ç”¨åˆ›å»ºç«¯å£ã€‚ä¾‹å¦‚ï¼š
<pre>
chrome.runtime.sendNativeMessage('com.my_company.my_application',
  { text: "æ‚¨å¥½" },
  function(response) {
    console.log("æ”¶åˆ° " + response);
  });
</pre>

<h2 id="security-considerations"><!--@Security considerations-->å®‰å…¨æ€§è€ƒè™‘</h2>

<p>
<!--@When receiving a message from a content script or another extension, your
background page should be careful not to fall victim to <a
href="http://en.wikipedia.org/wiki/Cross-site_scripting">cross-site
scripting</a>.  Specifically, avoid using dangerous APIs such as the
below:-->
å½“æ‚¨ä»å†…å®¹è„šæœ¬æˆ–å¦ä¸€ä¸ªæ‰©å±•ç¨‹åºæ¥æ”¶æ¶ˆæ¯æ—¶ï¼Œæ‚¨çš„åå°ç½‘é¡µåº”è¯¥å°å¿ƒï¼Œä»¥å…é­åˆ°<a
href="http://en.wikipedia.org/wiki/Cross-site_scripting">è·¨ç«™è„šæœ¬æ”»å‡»</a>ã€‚ç‰¹åˆ«åœ°ï¼Œé¿å…ä½¿ç”¨ä¸‹é¢è¿™äº›å±é™©çš„ APIï¼š
</p>
<pre data-filename="background.js">
chrome.tabs.sendMessage(tab.id, {greeting: "hello"}, function(response) {
  // è­¦å‘Šï¼å¯èƒ½ä¼šæ‰§è¡Œæ¶æ„è„šæœ¬ï¼
  var resp = eval("(" + response.farewell + ")");
});
</pre>
<pre data-filename="background.js">
chrome.tabs.sendMessage(tab.id, {greeting: "hello"}, function(response) {
  // è­¦å‘Šï¼å¯èƒ½ä¼šæ’å…¥æ¶æ„è„šæœ¬ï¼
  document.getElementById("resp").innerHTML = response.farewell;
});
</pre>
<p>
<!--@Instead, prefer safer APIs that do not run scripts:-->
æ‚¨åº”è¯¥é¦–é€‰ä¸è¿è¡Œè„šæœ¬çš„æ›´å®‰å…¨çš„APIï¼š
</p>
<pre data-filename="background.js">
chrome.tabs.sendMessage(tab.id, {greeting: "hello"}, function(response) {
  // JSON.parse ä¸ä¼šæ‰§è¡Œæ”»å‡»è€…çš„è„šæœ¬ã€‚
  var resp = JSON.parse(response.farewell);
});
</pre>
<pre data-filename="background.js">
chrome.tabs.sendMessage(tab.id, {greeting: "hello"}, function(response) {
  // innerText ä¸ä¼šè®©æ”»å‡»è€…æ’å…¥ HTML å…ƒç´ ã€‚
  document.getElementById("resp").innerText = response.farewell;
});
</pre>

<h2 id="examples"><!--@Examples-->ä¾‹å­</h2>

<p>
<!--@You can find simple examples of communication via messages in the-->
æ‚¨å¯ä»¥åœ¨
<a href="http://src.chromium.org/viewvc/chrome/trunk/src/chrome/common/extensions/docs/examples/api/messaging/">examples/api/messaging</a>
-->ç›®å½•ä¸­æ‰¾åˆ°ä½¿ç”¨æ¶ˆæ¯é€šä¿¡çš„ç®€å•ä¾‹å­ï¼Œ<a href="http://src.chromium.org/viewvc/chrome/trunk/src/chrome/common/extensions/docs/examples/api/nativeMessaging/">examples/api/nativeMessaging</a>
<!--@contains an example application that uses native messaging.
Also see the-->
åŒ…å«ä½¿ç”¨åŸç”Ÿæ¶ˆæ¯é€šä¿¡çš„ç¤ºä¾‹åº”ç”¨ç¨‹åºï¼Œå¦å¤–è¯·å‚è§
<a href="http://src.chromium.org/viewvc/chrome/trunk/src/chrome/common/extensions/docs/examples/howto/contentscript_xhr">contentscript_xhr</a> <!--@example,
in which a content script and its parent extension exchange messages,
so that the parent extension can perform
cross-site requests on behalf of the content script.
For more examples and for help in viewing the source code, see
<a href="samples.html">Samples</a>.-->
ä¾‹å­ï¼Œåœ¨è¿™ä¸ªä¾‹å­ä¸­å†…å®¹è„šæœ¬ä¸æ‰€å±æ‰©å±•ç¨‹åºäº¤æ¢æ¶ˆæ¯ï¼Œä»¥ä¾¿æ‰©å±•ç¨‹åºå¯ä»¥ä»£è¡¨å†…å®¹è„šæœ¬å‘å‡ºè·¨ç«™è¯·æ±‚ã€‚æœ‰å…³æ›´å¤šä¾‹å­ä»¥åŠæŸ¥çœ‹æºä»£ç çš„å¸®åŠ©ï¼Œè¯·å‚è§<a href="samples.html">ç¤ºä¾‹</a>ã€‚
</p>
      </div>
    </div>
  </body>

  <div id="gc-footer">
    <button class="google-button" id="scroll-to-top">â†‘</button>
    <button class="google-button" id="send-feedback" style="display:none">Send Feedback</button>
    <div class="text">
      <p>
        <!--@Except as otherwise <a href="http://code.google.com/policies.html#restrictions">noted</a>,
        the content of this page is licensed under the <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons
        Attribution 3.0 License</a>, and code samples are licensed under the
        <a rel="license" href="http://code.google.com/google_bsd_license.html">BSD License</a>.-->
        è¯¥é¡µé¢ç¿»è¯‘è‡ª
        <a href="https://developer.chrome.com/extensions/">Google Chrome Extensions</a>
        ä¸
        <a href="https://developer.chrome.com/apps/">Google Chrome Apps</a>ã€‚é™¤éç‰¹åˆ«<a href="https://code.google.com/policies.html#restrictions">è¯´æ˜</a>ï¼Œè¯¥é¡µé¢çš„å†…å®¹éµå¾ª
        <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0
        License</a>ï¼Œä»£ç ç¤ºä¾‹éµå¾ª
        <a rel="license" href="http://code.google.com/google_bsd_license.html">BSD License</a>ã€‚
      </p>
      <p class="crxdoczh-footer">
        <a href="https://code.google.com/p/crxdoczh/">crxdoczh é¡¹ç›®ä¸»é¡µ</a>
        <a href="https://code.google.com/p/crxdoczh/issues/entry?template=%E7%BD%91%E7%AB%99%E5%8F%8D%E9%A6%88">å‘é€åé¦ˆ</a>
        <a href="" rel="publisher">
          Google+ é¡µé¢
        </a>
        <a href="https://plus.google.com/communities/105384952265487436177">Google+ ç¤¾ç¾¤</a>
      </p>
      <script src="../../developer.chrome.com/static/js/platform_chooser.js" type="text/javascript"></script>
      <script src="../../developer.chrome.com/static/js/popup.js" type="text/javascript"></script>
      <script src="../../developer.chrome.com/static/js/prettify.js" type="text/javascript"></script>
      <script src="../../developer.chrome.com/static/js/scroll.js" type="text/javascript"></script>
      <script src="../../developer.chrome.com/static/js/sidebar.js" type="text/javascript"></script>
      <script src="../../developer.chrome.com/static/js/tabs.js" type="text/javascript"></script>
      <script>
        (function() {
          // Auto syntax highlight all pre tags.
          var preElements = document.getElementsByTagName('pre');
          for (var i = 0; i < preElements.length; i++) {
            var preElement = preElements[i];
            preElement.classList.add('prettyprint');
            var datasetFilename = preElement.getAttribute('data-filename');
            if (datasetFilename) {
              var filename = document.createElement('div');
              filename.className = 'filename nocode';
              filename.textContent = datasetFilename;
              preElement.insertBefore(filename, preElement.firstChild);
            }
          }
          prettyPrint();
        })();

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-25062424-1']);
        _gaq.push(['_trackPageview']);

        (function() {
          var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
          ga.src = 'https://ssl.google-analytics.com/ga.js';
          var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

        window.___gcfg = {
      Â  Â  lang: 'zh-CN'
      Â  };
      Â  (function() {
      Â  Â  var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
      Â  Â  po.src = 'https://apis.google.com/js/plusone.js';
      Â  Â  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
      Â  })();
      </script>
    </div>
  </div>
</html>
