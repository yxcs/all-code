### 我遇到过的 node 面试题：
1. 中间件是什么，什么原理    
   https://www.jianshu.com/p/797a4e38fe77   
   https://blog.csdn.net/u011413061/article/details/50518069

2. node 中如何解决跨域  
   就是CORS后端配合： https://blog.csdn.net/u012149969/article/details/81145144  
   要注意的是options请求

3. express 框架的理解   
  express是一个自身功能极简，完全是由路由和中间插件构成的一个web开发框架，从本质上讲一个express应用就是在调用各种中间插件。  
  http://blog.jobbole.com/41325/

4. fs 读取文件的过程  
  https://www.cnblogs.com/pp-cat/p/6504655.html  
  感觉是主要考了大文件存取问题 对于上M的文件，node.js的fs.readFiles是扛不住的，会报错，因为v8引擎的内存是有限制的，readFiles会一下子把整个文件加载进内存里面来，当然会越界。幸好nodejs提供了fs.ReadStream，可以一块块（默认64k,可以自己设置，具体参考官方文档）读取文件数据，内存就不会爆掉。大文件的复制一般用管道(管道提供了一个输出流到输入流的机制，将两边对接，流入流出)大概这样：
  ``` javascript
    var fs = require("fs");
    //创建一个可读流
    var readerStream = fs.createReadStream("input.txt");
    //创建一个可写流
    var writerStream = fs.creatWriteStream("output.txt");
    //复制，从输出流入到输入里面
    readerStream.pipe(writerStream);
  ```

5. 如何避免回调地狱
   - promise
   - async/await
   - generator函数  
   - 第三方插件 Q Async.js啥的

   https://www.cnblogs.com/greatluoluo/p/6288931.html

6. 什么是事件循环   
   基本上都有在问，还有的是问 nextTick setTimeout 执行顺序  

   https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/

7. Node.js的require依赖顺序  
8. 算法题，第一问是：给定一个整数金额的整钱n，还有2，3，5元三种货币，要你计算出所有能凑出整钱的组合个数
9. Node.js框架同其他语言框架的比较
10. 设计一个简单的红绿灯策略，比如红灯亮分别为console.log(“red”)这种，要求按照红3s-黄1s-绿1s顺序不断循环展示
11. 什么是错误优先的回调函数
12.  Node 的内存管理机制


什么是NodeJS
　　Node.js采用模块化结构，按照CommonJS规范定义和使用模块。模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件。

　　JS是脚本语言，脚本语言都需要一个解析器才能运行。对于写在HTML页面里的JS，浏览器充当了解析器的角色。而对于需要独立运行的JS，NodeJS就是一个解析器。

每一种解析器都是一个运行环境，不但允许JS定义各种数据结构，进行各种计算，还允许JS使用运行环境提供的内置对象和方法做一些事情。例如运行在浏览器中的JS的用途是操作DOM，浏览器就提供了document之类的内置对象。而运行在NodeJS中的JS的用途是操作磁盘文件或搭建HTTP服务器，NodeJS就相应提供了fs、http等内置对象。

　　Node.js 被设计用来开发大规模高并发的网络应用，这种网络应用的瓶颈之一是在 I/O 的处理效率上。由于硬件及网络的限制，I/O 的速度往往是固定的，如何在此前提下尽可能处理更多的客户请求，提高 CPU 使用效率，便成了开发人员面临的最大问题。得益于基于事件驱动的编程模型，Node.js 使用单一的 Event loop 线程处理客户请求，将 I/O 操作分派至各异步处理模块（这里一般人不理解，node.js包含很多模块，这些模块可以使用js直接调用系统的api），既解决了单线程模式下 I/O 阻塞的问题，又避免了多线程模式下资源分配及抢占的问题。

　　单线程模式：

　　客户端发起一个 I/O 请求(数据库查询)，然后等待服务器端返回 I/O 结果，结果返回后再对其进行操作，但这种请求常常需要很长时间（对于服务器的 CPU 处理能力来说）。这一过程中，服务器无法接受新的请求，即阻塞式 I/O。这种处理方式虽然简单，却不实用，尤其是面对大量请求的时候，简直就不可用。这种情景类似在火车站售票窗口排队买票，如果您在春节期间去北京火车站排队买过票，绝不会认为这是一种好的处理方式。庆幸的是，现在很少有服务器采取这种处理方式。

　　多线程模式：

　　该方式下，服务器为每个请求分配一个线程，所有任务均在自己的线程内执行，就像火车站多开了几个卖票窗口，处理效率高了许多。但就如读者看到的那样，在春节期间各个售票窗口前还是人满为患，为什么火车站不再多开一些售票窗口呢？当然是因为成本。线程也一样，服务器每创建一个线程，每个线程大概会占用 2M 的系统内存，而且线程之间的切换也会降低服务器的处理效率，基于成本的考虑，这种处理方式也有一定的局限性。然而，这却不是最主要的，主要的是开发多线程程序非常困难，容易出错。程序员需考虑死锁，数据不一致等问题，多线程的程序极难调试和测试。基本上在程序运行出错的时候，程序员才知道自己的程序有错误。而这种错误的代价往往又是巨大的，那些访问量巨大的电子商务网站时常会曝出价格错误等导致公司损失的新闻。

　　事件驱动：

　　客户发起 I/O 请求的同时传入一个函数，该函数会在 I/O 结果返回后被自动调用，而且该请求不会阻塞后续操作。就像电话订票，设想你一大早来到办公室，给火车站打个电话，将自己的票务信息，地址告诉对方，然后放下电话，泡杯茶，浏览一下网页，回复一下今天的电子邮件，你完全不用管火车票的事了，如果订到票，火车站会派快递公司按你电话中提到的联系方式送票给你。无疑，这是一种极其理想的处理方式。所有请求以及同时传入的回调函数均发送至同一线程，该线程通常叫做 Event loop 线程，该线程负责在 I/O 执行完毕后，将结果返回给回调函数。这里要注意的是 I/O 操作本身并不在该线程内执行，所以不会阻塞后续请求。比如：请求a要访问数据库，请求b要访问文件系统，假设Event loop先接受到a请求，这时Event loop会把a的回调方法交给处理访问数据库的异步处理模块。然后Event loop就可以去接受请求b,并把b的回调方法交给处理文件系统的一部处理模块。然后Event loop继续等待请求。当访问数据的异步处理模块处理完成后，会主动调用a的回调方法。在a的回调方法中，就会给客户a发送查询到的数据（当然这里需要短暂的使用Event loop来操作）。

　　

为什么选用 JavaScript
　　事实上，在实现 Node.js 之初，作者 Ryan Dahl 并没有选择 JavaScript，他尝试过 C、Lua，皆因其欠缺一些高级语言的特性，如闭包、函数式编程，致使程序复杂，难以维护。而 JavaScript 则是支持函数式编程范型的语言，很好地契合了 Node.js 基于事件驱动的编程模型。加之 Google 提供的 V8 引擎，使 JavaScript 语言的执行速度大大提高。最终呈现在我们面前的就成了 Node.js，而不是 Node.c，Node.lua 或其他语言的实现。Javascript的匿名函数和闭包特性非常适合事件驱动、异步编程。Javascript在动态语言中性能较好，有开发人员对Javacript、Python、Ruby等动态语言做了性能分析，发现Javascript的性能要好于其他语言，再加上V8引擎也是同类的佼佼者，所以Node.js的性能也受益其中。

Node.js采用C++语言编写而成，是一个Javascript的运行环境。为什么采用C++语言呢？据Node.js创始人Ryan Dahl回忆，他最初希望采用Ruby来写Node.js，但是后来发现Ruby虚拟机的性能不能满足他的要求，后来他尝试采用V8引擎，所以选择了C++语言。

Node.js采用了Google Chrome浏览器的V8引擎，性能很好，同时还提供了很多系统级的API，如文件操作、网络编程等。

Node.js是一个后端的Javascript运行环境（支持的系统包括*nux、Windows），这意味着你可以编写系统级或者服务器端的Javascript代码，交给Node.js来解释执行

多核处理器情况下

 

　　NodeJS中的JavaScript确实是在单线程上执行，但是作为宿主的NodeJS，它本身并非是单线程的，NodeJS在I/O方面又动用到一小部分额外的线程协助实现异步。程序员没有机会直接创建线程，这也是有的同学想当然的认为NodeJS的单线程无法很好的利用多核CPU的原因，他们甚至会说，难以想象由多人一起协作开发一个单线程的程序。

 

　　NodeJS封装了内部的异步实现后，导致程序员无法直接操作线程，也就造成所有的业务逻辑运算都会丢到JavaScript的执行线程上，这也就意味着，在高并发请求的时候，I/O的问题是很好的解决了，但是所有的业务逻辑运算积少成多地都运行在JavaScript线程上，形成了一条拥挤的JavaScript运算线程。NodeJS的弱点在这个时候会暴露出来，单线程执行运算形成的瓶颈，拖慢了I/O的效率。这大概可以算得上是密集运算情况下无法很好利用多核CPU的缺点。这条拥挤的JavaScript线程，给I/O形成了性能上限。

 

　　但是，事情又并非绝对的。回到前端浏览器中，为了解决线程拥挤的情况，Web Worker应运而生。而同样，Node也提供了child_process.fork来创建Node的子进程。在一个Node进程就能很好的解决密集I/O的情况下，fork出来的其余Node子进程可以当作常驻服务来解决运算阻塞的问题（将运算分发到多个Node子进程中上去，与Apache创建多个子进程类似）。当然child_process/Web Worker的机制永远只能解决单台机器的问题，大的Web应用是不可能一台服务器就能完成所有的请求服务的。拜NodeJS在I/O上的优势，跨OS的多Node之间通信的是不算什么问题的。解决NodeJS的运算密集问题的答案其实也是非常简单的，就是将运算分发到多个CPU上。　

　　在文章的写作中，Node最新发布的0.5.10版本新增了cluster启动参数。参数的使用方式如下：

node cluster server.js
　　启动Node的时候，在附加了该参数的情况下，Node会检测机器上的CPU数量来决定启动多少进程实例，这些实例会自动共享相同的侦听端口。

 

 

模块
编写稍大一点的程序时一般都会将代码模块化。在NodeJS中，一般将代码合理拆分到不同的JS文件中，每一个文件就是一个模块，而文件路径就是模块名。

在编写每个模块时，都有require、exports、module三个预先定义好的变量可供使用。

require
require函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者是绝对路径（以/或C:之类的盘符开头）。

exports
exports对象是当前模块的导出对象，用于导出模块公有方法和属性。别的模块通过require函数使用当前模块时得到的就是当前模块的exports对象。

module
通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通对象，如果想改成一个函数的话，可以使用以下方式。


 
 
module.exports = function () {
    console.log('Hello World!');
};
以上代码中，模块默认导出对象被替换为一个函数。

模块初始化
一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出对象。之后，缓存起来的导出对象被重复利用。

主模块
通过命令行参数传递给NodeJS以启动程序的模块被称为主模块。主模块负责调度组成整个程序的其它模块完成工作。例如通过以下命令启动程序时，main.js就是主模块。

 
$ node main.js
二进制模块
虽然一般我们使用JS编写模块，但NodeJS也支持使用C/C++编写二进制模块。编译好的二进制模块除了文件扩展名是.node外，和JS模块的使用方式相同。虽然二进制模块能使用操作系统提供的所有功能，拥有无限的潜能，但对于前端同学而言编写过于困难，并且难以跨平台使用