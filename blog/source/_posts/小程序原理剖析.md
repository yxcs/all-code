---
title: 小程序原理剖析
categories: 前端
tags:
  - 小程序
  - webview
abbrlink: 55554
date: 2018-09-20 13:43:16
---

### webview 和 native
随着公众号的出现和繁荣，WebView 的使用频率也越来越高，但是webview有自己的顽疾：加载白屏、面切换的生硬和点击的迟滞感  
而native虽然性能很好，有很好的兼容性，但是必须要下载新版APP才能更新

需求 | Native | Native | 期望
- | :-: | :-: | -: 
开发门槛 | 高| 低 | 低
体验 | 好 | 白屏、交互反馈差 | 接近原生体验
版本更新 | 需审核，迭代慢 | 在线更新 |　在线更新
管控性 | 平台可管控 | 难管控 | 可管控

两种方式都无法满足需求，所以小程序开始酝酿，已达到期望  
小程序的优点：
- 使用 WebView 开发，门槛低，可云端更新
- 通过提供基础能力、原生组件结合等方式，提升用户体验
- 通过平台发布、审核、下架、封禁等能力，具备对小程序的管控能力
- 双线程（逻辑层和渲染层分开），隔离 DOM、BOM 能力，提升体验的同时，可保证 WebView 安全性
- 微信小程序是基于微信运行的，所以可以得到微信的直接支持，可以调用很多微信的功能，例如： 二维码扫描、搜索、分享、推送等。。。

### 渲染方式
小程序选择了 Hybrid 的渲染方式，可以用一种近似 Web 的方式来开发，并且还可以实现在线更新代码。同时，引入原生组件有以下好处：
1. 扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力
2. 体验更好，同时也减轻 WebView 的渲染工作
3. 绕过 setData、数据通信和重渲染流程，使渲染性能更好

### 小程序的双线程
虽然解决了以上问题，但是 **管控性和安全性**还没有解决，那么如何解决那 ？   
于是，双线程的设计被提出来了。  

![微信官方双线程示意图](https://github.com/yxcs/yxcs-blog/raw/master/static_img/miniprograme_process.png)

小程序的渲染层和逻辑层分别由 2 个线程管理：渲染层的界面使用了 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS 脚本。

为什么要这么设计呢？前面提到的管控和安全，为了解决这些问题，所以需要阻止开发者使用一些浏览器提供的，诸如跳转页面、操作 DOM、动态执行脚本的开放性接口。

可以使用客户端系统的 JavaScript 引擎，iOS下的 JavaScriptCore 框架，安卓下腾讯 x5 内核提供的 JsCore 环境。通过提供一个沙箱环境来运行开发者的 JavaScript 代码来解决。这个沙箱环境只提供纯 JavaScript 的解释执行环境，没有任何浏览器相关接口。

这就是小程序双线程模型的由来：

- 逻辑层：创建一个单独的线程去执行 JavaScript，在这个环境下执行的都是有关小程序业务逻辑的代码
- 渲染层：界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程

### 双线程通信 
逻辑层和渲染层的通信会由 Native （微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发，可以简单的理解为DOM 的更新通过简单的数据通信来实现
和Virtual DOM 类似，概是这么个过程：用JS对象模拟DOM树 -> 比较两棵虚拟DOM树的差异 -> 把差异应用到真正的DOM树上

![小程序双线程通信](https://github.com/yxcs/yxcs-blog/raw/master/static_img/miniprograme_message.png)

1. 在渲染层把 WXML 转化成对应的 JS 对象。
2. 在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。
3. 经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。

因为双线程的存在，所以小程序有天生的延迟

这样完整的一套框架，基本上都是通过小程序的基础库来完成的

### 小程序的基础库(WAService.js)
小程序的基础库是 JavaScript 编写的，它可以被注入到渲染层和逻辑层运行。主要用于：

1. 在渲染层，提供各类组件来组建界面的元素
2. 在逻辑层，提供各类 API 来处理各种逻辑
3. 处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑
由于小程序的渲染层和逻辑层是两个线程管理，两个线程各自注入了基础库。小程序的基础库不会被打包在某个小程序的代码包里边，它会被提前内置在微信客户端。这样可以：

1. 降低业务小程序的代码包大小
2. 可以单独修复基础库中的 Bug，无需修改到业务小程序的代码包


**Exparser 框架**
Exparser 是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由 Exparser 组织管理。Exparser 特点包括：

1. 基于 Shadow DOM 模型：模型上与 WebComponents 的 ShadowDOM 高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他API以支持小程序组件编程。
2. 可在纯JS环境中运行：这意味着逻辑层也具有一定的组件树组织能力。
3. 高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。  

而原生的组件是在webview中提供一个相应大小的占位，会在native里边直接覆盖原生的组件，所以原生逐渐不会被基础组件覆盖（**这也是提供cover-view的原因**）

### 解析内核分析
微信小程序使用了前端技术栈 JavaScript/WXML/WXSS。但和常规的前端开发又有一些区别：

1. JavaScript：微信小程序的 JavaScript 运行环境即不是 Browser 也不是 Node.js。它运行在微信 App 的上下文中，不能操作 Browser context 下的 DOM，也不能通过 Node.js 相关接口访问操作系统 API。所以，严格意义来讲，微信小程序并不是 Html5，虽然开发过程和用到的技术栈和 Html5 是相通的
2. WXML: 作为微信小程序的展示层，并不是使用 Html，而是自己发明的基于 XML 语法的描述
3. WXSS: 用来修饰展示层的样式。官方的描述是 “ WXSS (WeiXin Style Sheets) 是一套样式语言，用于描述 WXML 的组件样式。WXSS 用来决定 WXML 的组件应该怎么显示。” “我们的 WXSS 具有 CSS 大部分特性…我们对 CSS 进行了扩充以及修改”。使用的时css3的语法，但是不支持css3的大部分选择器，只支持少部分。同时添加了对wxml原生组件的选择器

#### 微信小程序运行在三端：iOS、Android 和 用于调试的开发者工具
> 1. 在 iOS 上: 小程序的 javascript 代码是运行在 JavaScriptCore 中
> 2. 在 Android 上: 小程序的 javascript 代码是通过 X5 内核来解析
> 3. 在 开发工具上: 小程序的 javascript 代码是运行在 nwjs（chrome内核） 中

### IOS
- 视图组件通信： iOS 是利用了WKWebView 的提供 messageHandlers 
-  逻辑层通信： iOS平台可以往JavaScripCore框架注入一个全局的原生方
### Android
- 视图组件通信和逻辑层通信： 往 WebView 的 window 对象注入一个原生方法，最终会封装成 WeiXinJSBridge 这样一个兼容层，主要提供了调用（invoke）和监听（on）这两种方法
### 开发工具 
小程序的 javascript 代码运行在 nwjs 中
nwjs 合并 Browser 和 Node.js 的运行时，可以使用前端开发技术来开发跨平台的应用程序。借助 Node.js 访问操作系统原生 API 的能力，可以开发中跨平台的应用程序。微信小程序开发工具就是使用 nwjs 开发的
#### Electron vs nwjs

##### 从技术角度来讲：  
* 应用程序入口不同：Electron 入口是一个 javascript 脚本，脚本里要自己负责创建浏览器窗口，加载 html 页面。而 nwjs 的入口就是一个 html 页面，框架自己会创建浏览器窗口来显示这个 html 页面。
* Node.js 集成方式不同：Electron 直接使用 Node.js 的共享库，不需要修改 Chromium 代码。而 nwjs 为了集成 Node.js ，需要修改 Chromium 代码，以便在浏览器里能通过 Node.js 访问系统原生 API。
* Multi-Context: nwjs 有多个上下文，一个是浏览器的上下文，用来访问 Browser 相关 API，比如操作 DOM ，另外一个是 Node 上下文，用来访问操作系统 API。Electron 没有使用多个上下文，对开发者更友好。

##### 从应用角度来讲：  
* 打包后的文件大小：Electron 打包后文件会比 nwjs 小不少。一个 18M 的程序，使用 Electron 打包后是 117M，而使用 nwjs 打包后的程序是 220M。微信小程序开发工具打包后是 219M (v0.10.102800)。没有亲测，评价来源参考文档。
* 代码保护：Electron 只支持代码混淆来保护，而 nwjs 把核心代码放在 V8 引擎里，不但可以保护代码，还可以提高执行效率。
* 开源社区活跃度：Electron 应该是完胜的。看看使用 Electron 构建的应用程序就知道了。而据说 nwjs 的开发文档有些都没有及时更新。
* 应用程序启动时间：Electron 会稍微快一点。没有亲测，评价来源参考文档。

##### 从这个分析猜测，微信选择 nwjs 的原因可能是出于代码保护。毕竟开发工具可以上传小程序，有些接口和数据需要比较严密的保护


关于基础库和 Exparser 框架，更多的也可以参考：[《小程序开发指南》](https://developers.weixin.qq.com/ebook?action=get_post_info&token=935589521&volumn=1&lang=zh_CN&book=miniprogram&docid=0008aeea9a8978ab0086a685851c0a)