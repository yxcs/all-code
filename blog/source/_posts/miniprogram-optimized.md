---
title: 小程序相关优化
categories: 前端
tags:
  - js
  - 小程序
abbrlink: 14756
date: 2018-12-06 16:26:57
---

### First Of All

小程序相比于H5网站性能更好，同时可以调用h5无法调用的或者H5无法实现的功能，这是小程序的优势。但是小程序也有自己的弊端，例如小程序的代码包大小被限制在2M，超过该大小则无法上传，同时因为小程序云星宇宿主APP中，这就要求你的小程序要有好的性能，你的代码要有好的优化，这里将讲一下小程序相关的优化。
那么，什么样的小程序算是好的小程序那？我认为至少包括以下几点：(不考虑产品、运营、推广等，就单说技术方面)  

- 小程序冷加载速度要快
- 页面或者功能响应速度要快
- 要有好的提示和UI响应
- 除此之外，在代码方面要做好组件等的封装，js、css等要做好规范，在开发小程序之前尽量规范好全局、局部代码等...

### 一. 图片资源优化

1. 在不影响用户观看图片质量的情况下，尽可能的压缩图片
2. 将图片放到cdn上，或者小程序云上，减少本地程序包大小，一方面是因为小程序2M的限制，另一方面和小程序首屏加载的过程有关(之后讲解)
3. 对多图片进行懒加载，最简单的方式是使用<**image**>的lazy-load，但是要注意这个属性只针对page与scroll-view下的image有效，当然你也可以自己写一些基于小程序的懒加载组件
4. 其他的例如雪碧图等，H5上常见的这里就不多说了

### 二. 代码优化

#### 代码优化的必要性   

在之前开发小程序的过程中，因为是接手别人的项目(是的，我是接盘侠)，他们在开发的过程中着眼于快速开发完成，实现产品的功能，并未考其他相关的东西，例如：

- 当功能逐步增加代码量随之提升，导致程序包超过2M
- 很多相似的功能每次开发都要重新写一遍是不是很蛋疼
- 一些常量、环境变量、地图相关值等等的配置问题  

当你遇到这样的问题时，你会发现很多代码，甚至是整个项目的结构都有需要优化的地方，而且是必须优化。

#### 优化方法

1. 在开发之初，首先是要搞清楚小程序服务的类型，即是电商类、新闻类、服务类等等，根据类型猜测可能需要实现的功能模块，例如登录、支付、地址定位等等在搭建框架之初就要考虑这些模块怎样实现，全局如何调用，否则等开发到的时候再去考虑，可能会造成以前代码加入新内容有问题，或者无法实现全局的功能新增。
   例如登录模块：之前微信的规则是允许直接调用API弹窗显示，但是从2018-10-10之后，就只能是用户主动点击按钮，才可以触发。很多的小程序必须用户授权才能使用，在开发这样的功能时，一定要提前设计。如果小程序已经开发完成，但是要更改该模块，那么要做好完善的规划，要考虑好怎样要用户点击登录、登陆后的页面跳转、不登录的页面跳转、不同场景进到不同页面时的登录判断以及登录跳转……
2. 可以将小程序自带的请求封装成Promise或者aysnc和await，因为小程序自带的请求如wx.request()，是通过回调函数来获取返回数据的，这就引出了回调地狱问题。小程序支持es6转码，所以可以将所有的请求都封装到一个文件当中，方便调用。
  除了小程序自带的请求，还有向后端调用的API，也可以封装到一个单独的文件中，在页面内调用对文件中函数的引用，这样可以实现代码复用，减少代码，当后端接口出现大规模变动的时候(例如接口优化升级)也可以很完美的更改前端调用
  在调用后端接口的时候，要考虑到接口报错、接口成功、接口数据为空、传参格式、传参为空处理以及请求头信息的传递
3. 在写wxml的时候，要注意删减没有必要的代码，在实现功能的时候使用最少的代码，可以把相同的代码提取到template中，进行复用。相似的几个页面可以统一的放到同一个页面当中，根据不同参数进行渲染，毕竟每新创建一个页面都要产生4个文件，增加小程序注册时页面注册时间
4. wxss可以写在3个地方，第一个是全局样式app.wxss中，第二个是每个页面的wxss中，还有就是独立出来的可以通过@important引用到其他wxss页面中的样式。那么在规划wxss的时候，要考虑到不同的样式放到不同的地方，所有页面都可以用到样式例如主题颜色等就直接放到app.wxss中，而只在几个相似的页面中调用的样式可以放到独立文件中，需要的页面进行引用，只在当前页面使用的样式直接放到页面wxss中即可。
   在写wxss的时候，可以使用很多css3的属性，因为在小程序中css3的支持行很好，注意学习新的css技术，建议使用Flex布局替代float。
   其实还有一个样式书写在组件当中，这里就不说了。
5. 尽量避免使用base64图片，虽然用起来很方便，但是仍然会占用代码大小，还会影响代码质量
6. 将反复用到的功能，或者多个页面都用到的功能，封装到一个组件，方便复用，同时代码只写一遍，更改的话也只更改一个文件。也减少了代码量
7. 在小程序中跨页面数据共享要时常用到，一般的方式有4种：App.js的globalData、本地storage存储、通过后端保存、状态机。推荐使用状态机的方式，也就是类似于vuex、redux等。本地存储大小有限制，globalData无法实时更新数据，后端保存性能不好，同时需要更多人配合。
8. setData的优化
   在开发小程序的时候要时常用到setData函数，在调用setData的时候分为两个步骤：首先在当前js中更改数据，然后将数据传给页面，页面进行页面数据和展示的更改，第一步是同步的，第二个是异步的。为什么会分为两步那？这个就要从小程序的机制说起了。
   ![小程序数据传递模式图片](https://github.com/yxcs/yxcs-blog/raw/master/static_img/mp_setdata.png)
   如图所示，js是没有直接操控页面的，需要经过中间的原生App进行传达，用户在页面进行操作时Webview收到用户操作，并通过原生APP通知js，所以用户的操作总是会有一定的延迟。
   当setData的时候，第一步是将jsCore部分的数据更新，不需要经过Native，所以是同步的。第二步是将数据传到Webview，经过Native，是异步的。在js中是可以不通过setData直接更新数据的，但是这会造成渲染层和逻辑层的数据不一致，会导致很多问题。
   在了解了setData的运行机制之后，就可以发现在调用setData的时候有很多内容可以优化：   
   * 因为setData要经过Native传递，数据量大则传递速度慢，所以在setData的时候要尽量精简内容(单次设置的数据不能超过1024kb)
   * 使用简单的数据结构，在Native传数据到webview之后要进行数据的对比，根据对比之后得到的差异结果，进行重新渲染，使用简单的数据结构，加快对比的速度
   * 减少调用setData的次数
   * 不要把data中任一项的value设为undefined，否则这一项将不被设置并可能遗留一些潜在问题
   * 当页面进入后台之后，不应该再继续执行setData
   * 将页面不展示的内容，放到data以外的地方
9. 在设置setTImeout和setInteval时，要注意及时清除，减少页面重绘以及数据传输，提高网页性能
10. 在写代码时，在需要的地方使用try、catch，这样可以避免不必要的报错导致页面挂掉。但是不要滥用，因为try、catch的性能不是很好
11. 在使用额外的插件的时候，一定要考虑插件的性能适不适合移动端，适不适合小程序，同时要考虑插件本身的大小
12. 将本地代码压缩后再上传至服务器
13. wx:if vs hidden wwx:if是如果在初始渲染条件为false时，框架什么也不会做，只有当值变为真时，才开始局部渲染。hidden只是简单的控制显示与隐藏，组件始终会被渲染。wx:if有更高的切换消耗，而hidden有更高的初始渲染消耗。在使用时根据场景来进行区分。(貌似hidden有问题)
14. 减少后台接口调用，将一些常用的数据或者不变的数据保存到本地
15. 提前请求，可以将请求放到onload中，而不是ready后再去异步请求数
16. 避免白屏，当数据加载的时候，尽量在页面上给出一些必要的提示或者说明，也可以使用骨架屏的占位等，使用户不会等待的很焦虑，甚至走了。
17. 要让用户知道他的每一个操作都得到了反馈，都有实际效果，如果页面不能及时的响应用户的操作，尽量给一些提示，避免用户以为小程序卡了，无响应。
18. 避免不当的使用onPageScroll
    
### 三. 首屏加载优化

小程序在第一次打开时的加载过程是这样的：下载小程序代码包 => 加载小程序代码包 => 初始化小程序首页。

![小程序第一次加载过程图](https://github.com/yxcs/yxcs-blog/raw/master/static_img/mp_loading.png)

以上是三个过程对应的三种页面状态  
1. 小程序会先把代码包下载下来，包括代码包里的图片等静态资源，所以代码包一定要尽可能的小。避免用户认为是小程序打不开而跳走。从开发者的角度看，控制代码包大小有助于减少小程序的启动时间。对低于1MB的代码包，其下载时间可以控制在 **929ms（iOS）、1500ms（Android）** 内。
   * 勾选开发者工具中“上传代码时，压缩代码”选项；
   * 及时清理无用的代码和资源文件（包括无用的日志代码）
   * 减少资源包中的图片等资源的数量和大小（理论上除了小icon，其他图片资源从网络下载），图片资源压缩率有限
2. 在代码下载下来之后，会对代码进行加载运行，如果页面过多会加载很长时间，注要注意控制路由的数量。
   有的时候根据业务的需求，和功能的增加，代码量和页面数量都会过多这个时候只是压缩或者删减不必要的代码时没法达到很好的优化效果的，这时可以考虑一下小程序的分包加载。
   根据业务场景，将用户访问率高的页面放在主包里，将访问率低的页面放入子包里，按需加载；

   ![分包加载示意图](https://github.com/yxcs/yxcs-blog/raw/master/static_img/mp_fenbao.png)

   使用分包时需要注意代码和资源文件目录的划分。启动时需要访问的页面及其依赖的资源文件应放在主包中。
   
   **采用分包预加载技术：** 当用户点击到子包的目录时，还是有一个代码包下载的过程，这会感觉到明显的卡顿，所以子包也不建议拆的太大，当然我们可以采用子包预加载技术，并不需要等到用户点击到子包页面后在下载子包，而是可以根据后期数据，做子包预加载，将用户在当先页可能点击的子包页面先加载，当用户点击后直接跳转；
   **采用独立分包技术：** 目前很多小程序主包+子包（2M+6M）的方式，但是在做很多运营活动时，我们会发现活动（红包）是在子包里，但是运营、产品投放的落地页链接是子包链接，这是的用户在直达落地时，必须先下载主包内容（一般比较大），在下载子包内容（相对主包，较小），这使得在用户停留时间比较短的小程序场景中，用户体验不是很好，而且浪费了很大部分流量；

    [参考链接](https://blog.csdn.net/i10630226/article/details/81042421 "微信小程序：一些运行细节及针对性的优化策略")
3. 使用预加载技术
   > 这个是一个大问题，之后会写相关的分享。简单的说就是当用户点击跳转时，会有150ms的延迟才会跳到相应的页面，这个和小程序的原理有关。预加载可以利用这一延迟的时间，进行接口请求，减少用户到达目的页面的等待时间。

### 四. 骨架屏优化
在前端除了以上的优化外，还有UI显示的优化。例如上面说的当用户点击一个按钮跳转时，会有150ms的延迟。那么当点击时，可以给这个按钮一个100ms的动画效果，或者激活的状态，让用户知道他的操作在起作用中。上面也讲了避免白屏等问题，现在流行的解决的方式是骨架屏，这也是一个很好的UI的优化。
骨架屏(Skeleton Screen) 就是在页面数据尚未加载前先给用户展示出页面的大致结构，直到请求数据返回后再渲染页面，补充进需要显示的数据内容。常用于文章列表、动态列表页。
在骨架屏出来之前，在数据未加载出来时，常见的显示方式是展示一个全屏的锁屏loading，数据加载之后隐藏loading，但是锁屏loading在一定程度限制了用户的操作，所以为了进一步提升用户体验，Skeleton Screen被越来越多的公司产品采用，如：Facebook、简书、知乎、掘金等，在动态、文章加载时预先渲染出结构布局，数据加载完成后再填充数据显示，这样的好处在于不干扰用户操作，使用户对于加载的内容有一个大致的预期，特别是弱网络环境下极大的优化了用户体验。

![骨架屏 饿了么demo](https://github.com/yxcs/yxcs-blog/raw/master/static_img/mp-SkeletonScreen_demo.jpg)

骨架屏并不是一种新的技术，而是一种显示方式。实现骨架屏主要有2个步骤： 
  1. 创建与显示内容相似的html结构 
  2. 在需要显示内容的元素上增加背景色

常见的效果有以下3种：
1. 简单堆砌出元素结构
   ![骨架屏 简单堆砌出元素结构](https://github.com/yxcs/yxcs-blog/raw/master/static_img/mp-SkeletonScreen1.png)
   ```html
    <view class="skeleton">
      <view class="skeleton-head"></view>
      <view class="skeleton-body">
        <view class="skeleton-title"></view>
        <view class="skeleton-content"></view>
      </view>
    </view>
   ```
   ```css
    .skeleton {
      padding: 10rpx;
    }
    .skeleton .skeleton-head,
    .skeleton .skeleton-title,
    .skeleton .skeleton-content {
      background: rgb(194, 207, 214);
    }
    .skeleton-head {
      width: 100rpx;
      height: 100rpx;
      float: left;
    }
    .skeleton-body {
      margin-left: 110rpx;
    }
    .skeleton-title {
      width: 500rpx;
      height: 60rpx;
    }
    .skeleton-content {
      width: 260rpx;
      height: 30rpx;
      margin-top: 10rpx;
    }
   ```
2. 背景动画，html结构相同，修改部分css样式
  ![骨架屏 背景动画](https://github.com/yxcs/yxcs-blog/raw/master/static_img/mp-SkeletonScreen2.gif)
   ```css
    .skeleton .skeleton-head,
    .skeleton .skeleton-title,
    .skeleton .skeleton-content {
      background: rgb(194, 207, 214);
      background-image: linear-gradient(90deg,rgba(255, 255, 255, 0.15) 25%, transparent 25%);
      background-size: 20rem 20rem;
      animation: skeleton-stripes 1s linear infinite;
    }
    @keyframes skeleton-stripes {
      from {
        background-position: 0 0 ;
      }
      to {
        background-position: 20rem 0;
      }
    }
   ```

3. 元素结构长度变化
  ![骨架屏 元素结构长度变化](https://github.com/yxcs/yxcs-blog/raw/master/static_img/mp-SkeletonScreen3.gif)
    ```css
      .skeleton {
        padding: 10rpx;
      }
      .skeleton .skeleton-head,
      .skeleton .skeleton-title,
      .skeleton .skeleton-content {
        background: rgb(194, 207, 214);
      }
      .skeleton-head {
        width: 100rpx;
        height: 100rpx;
        float: left;
      }
      .skeleton-body {
        margin-left: 110rpx;
      }
      .skeleton-title {
        width: 500rpx;
        height: 60rpx;
        transform-origin: left;
        animation: skeleton-stretch .5s linear infinite alternate;
      }
      .skeleton-content {
        width: 260rpx;
        height: 30rpx;
        margin-top: 10rpx;
        transform-origin: left;
        animation: skeleton-stretch .5s -.3s linear infinite alternate;
      }
      @keyframes skeleton-stretch {
        from {
          transform: scalex(1);
        }
        to {
          transform: scalex(.3);
        }
      }
    ```


### 五. 总结
小程序项目的优化要从小程序的运行原理和运行机制出发，才能明白哪里需要优化、为什么需要优化以及怎样优化。
如果有问题或者意见请及时沟通。